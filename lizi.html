<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
      :root {
        --primary-color: #00f3ff;
        --panel-bg: rgba(20, 20, 25, 0.85);
        --text-color: #ffffff;
        --btn-hover: rgba(255, 255, 255, 0.1);
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #050505;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      /* 3D ç”»å¸ƒ */
      #canvas-container {
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 1;
      }

      /* éšè—çš„è§†é¢‘å…ƒç´ ï¼Œç”¨äº MediaPipe å¤„ç† */
      #input-video {
        display: none;
      }

      /* æ‘„åƒå¤´é¢„è§ˆå°çª— (å¯é€‰ï¼Œæ–¹ä¾¿ç”¨æˆ·å®šä½) */
      #camera-preview {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 160px;
        height: 120px;
        border-radius: 8px;
        border: 2px solid var(--primary-color);
        z-index: 2;
        transform: scaleX(-1); /* é•œåƒ */
        opacity: 0.2;
        background: #000;
      }

      /* UI é¢æ¿ */
      #ui-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 280px;
        background: var(--panel-bg);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 12px;
        z-index: 10;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.3s ease;
      }

      h2 {
        color: var(--text-color);
        margin: 0 0 15px 0;
        font-size: 18px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* æ§åˆ¶ç»„ */
      .control-group {
        margin-bottom: 20px;
      }

      .control-label {
        color: #aaa;
        font-size: 12px;
        margin-bottom: 8px;
        display: block;
      }

      /* æŒ‰é’®ç½‘æ ¼ */
      .shape-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      button {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text-color);
        padding: 10px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 13px;
      }

      button:hover {
        background: var(--btn-hover);
        border-color: var(--primary-color);
      }

      button.active {
        background: var(--primary-color);
        color: #000;
        font-weight: bold;
      }

      /* é¢œè‰²é€‰æ‹©å™¨ */
      input[type='color'] {
        width: 100%;
        height: 40px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: transparent;
      }

      /* åŠ è½½é®ç½© */
      #loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 99;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        transition: opacity 0.5s;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
      #status-indicator {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        padding: 8px 16px;
        border-radius: 20px;
        color: white;
        font-size: 12px;
        z-index: 5;
        display: flex;
        align-items: center;
        gap: 8px;
        pointer-events: none;
      }

      .dot {
        width: 8px;
        height: 8px;
        background: #ff3333;
        border-radius: 50%;
      }
      .dot.active {
        background: #00ff00;
        box-shadow: 0 0 10px #00ff00;
      }

      /* å…¨å±æŒ‰é’® */
      #fullscreen-btn {
        width: 100%;
        margin-top: 10px;
        background: rgba(255, 255, 255, 0.1);
      }
    </style>

    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loader">
      <div class="spinner"></div>
      <div id="loader-text">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“...<br />è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- çŠ¶æ€æŒ‡ç¤º -->
    <div id="status-indicator">
      <div class="dot" id="hand-dot"></div>
      <span id="status-text">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«...</span>
    </div>

    <!-- è§†é¢‘è¾“å…¥ (éšè—) -->
    <video id="input-video"></video>
    <!-- æ‘„åƒå¤´å°çª—é¢„è§ˆ -->
    <canvas id="camera-preview"></canvas>

    <!-- 3D å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- UI é¢æ¿ -->
    <div id="ui-panel">
      <h2>
        æ§åˆ¶é¢æ¿
        <span style="font-size: 10px; opacity: 0.6">v1.0</span>
      </h2>

      <div class="control-group">
        <span class="control-label">æ¨¡å‹é€‰æ‹©</span>
        <div class="shape-grid">
          <button class="active" onclick="setShape('heart')">â¤ï¸ çˆ±å¿ƒ</button>
          <button onclick="setShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
          <button onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
          <button onclick="setShape('buddha')">ğŸ§˜ ä½›åƒ</button>
          <button onclick="setShape('firework')">ğŸ† çƒŸèŠ±</button>
          <button onclick="setShape('sphere')">ğŸ”® çƒä½“</button>
        </div>
      </div>

      <div class="control-group">
        <span class="control-label">ç²’å­é¢œè‰²</span>
        <input type="color" id="color-picker" value="#00f3ff" />
      </div>

      <div class="control-group">
        <button id="fullscreen-btn" onclick="toggleFullScreen()">â›¶ å…¨å±æ¨¡å¼</button>
      </div>

      <div style="font-size: 11px; color: #666; margin-top: 10px; line-height: 1.4">
        æ“ä½œè¯´æ˜ï¼š<br />
        1. åŒæ‰‹åœ¨æ‘„åƒå¤´å‰å¼ å¼€/åˆæ‹¢æ§åˆ¶å¤§å°ã€‚<br />
        2. åˆ‡æ¢æ¨¡å‹ä½“éªŒä¸åŒçš„ç²’å­å½¢æ€ã€‚<br />
      </div>
    </div>

    <script>
      // ================= é…ç½®ä¸å…¨å±€å˜é‡ =================
      const CONFIG = {
        particleCount: 20000,
        particleSize: 0.15, // ç²’å­åŸºç¡€å¤§å°
        transitionSpeed: 0.08, // å˜å½¢é€Ÿåº¦
        handSensitivity: 2.0, // æ‰‹åŠ¿çµæ•åº¦
      }

      let scene, camera, renderer, particles, geometry
      let targetPositions = [] // ç›®æ ‡å½¢çŠ¶çš„åæ ‡æ•°ç»„
      let currentPositions = [] // å½“å‰åæ ‡æ•°ç»„
      let baseColor = new THREE.Color(0x00f3ff)

      // äº¤äº’çŠ¶æ€
      let handScale = 1.0 // æ‰‹åŠ¿æ§åˆ¶çš„ç¼©æ”¾å› å­
      let targetScale = 1.0
      let isHandDetected = false
      let currentShape = 'heart'

      // åª’ä½“æµç›¸å…³
      const videoElement = document.getElementById('input-video')
      const previewCanvas = document.getElementById('camera-preview')
      const previewCtx = previewCanvas.getContext('2d')

      // ================= 1. Three.js åœºæ™¯åˆå§‹åŒ– =================
      function initThree() {
        const container = document.getElementById('canvas-container')

        // åœºæ™¯
        scene = new THREE.Scene()
        scene.fog = new THREE.FogExp2(0x050505, 0.02)

        // ç›¸æœº
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.z = 30

        // æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(window.devicePixelRatio)
        container.appendChild(renderer.domElement)

        // åˆ›å»ºç²’å­
        createParticles()

        // ç¯å…‰ (è™½ç„¶æ˜¯ PointCloudï¼Œä½†åŠ ç‚¹ç¯å¢ƒå…‰ä»¥å¤‡æ‰©å±•)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
        scene.add(ambientLight)

        // äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', onWindowResize, false)

        // é¢œè‰²é€‰æ‹©å™¨
        document.getElementById('color-picker').addEventListener('input', e => {
          baseColor.set(e.target.value)
          if (particles) particles.material.color.set(baseColor)
        })
      }

      // åˆ›å»ºç²’å­ç³»ç»Ÿ
      function createParticles() {
        geometry = new THREE.BufferGeometry()
        const positions = new Float32Array(CONFIG.particleCount * 3)

        // åˆå§‹åŒ–ä½ç½®ï¼ˆéšæœºçƒä½“ï¼‰
        const spherePoints = getSpherePoints(CONFIG.particleCount, 10)
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
          positions[i] = spherePoints[i]
          currentPositions[i] = spherePoints[i]
        }

        // åˆå§‹åŒ–ç›®æ ‡ä½ç½®ä¸ºå¿ƒå½¢
        const heartPoints = getHeartPoints(CONFIG.particleCount)
        targetPositions = heartPoints

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

        // æè´¨
        const material = new THREE.PointsMaterial({
          color: baseColor,
          size: CONFIG.particleSize,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        })

        particles = new THREE.Points(geometry, material)
        scene.add(particles)
      }

      // ================= 2. å½¢çŠ¶ç®—æ³•ç”Ÿæˆå™¨ =================

      // è¾…åŠ©ï¼šéšæœºå–ç‚¹
      function randomPointInSphere(radius) {
        const u = Math.random()
        const v = Math.random()
        const theta = 2 * Math.PI * u
        const phi = Math.acos(2 * v - 1)
        const r = Math.cbrt(Math.random()) * radius
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
        }
      }

      // 1. çƒä½“
      function getSpherePoints(count, radius = 10) {
        const arr = new Float32Array(count * 3)
        for (let i = 0; i < count; i++) {
          const p = randomPointInSphere(radius)
          arr[i * 3] = p.x
          arr[i * 3 + 1] = p.y
          arr[i * 3 + 2] = p.z
        }
        return arr
      }

      // 2. çˆ±å¿ƒ
      function getHeartPoints(count) {
        const arr = new Float32Array(count * 3)
        for (let i = 0; i < count; i++) {
          // Heart formula transformation
          let x, y, z
          // ä½¿ç”¨æ‹’ç»é‡‡æ ·æ³•ä½¿å½¢çŠ¶æ›´å‡åŒ€ï¼Œæˆ–è€…å‚æ•°æ–¹ç¨‹
          const t = Math.random() * Math.PI * 2
          const u = Math.random() * Math.PI

          // 3D Heart parametric equation
          // x = 16sin^3(t)
          // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
          // z å˜ä½“å¢åŠ åšåº¦

          // æ›´ç®€å•çš„ä½“ç§¯å¡«å……ç‰ˆæœ¬
          const r = Math.sqrt(Math.random())
          const phi = Math.random() * Math.PI * 2
          const theta = Math.random() * Math.PI

          // ç®€å•çš„ 2D æ‹‰ä¼¸æˆ 3D
          const hx = 16 * Math.pow(Math.sin(phi), 3)
          const hy = 13 * Math.cos(phi) - 5 * Math.cos(2 * phi) - 2 * Math.cos(3 * phi) - Math.cos(4 * phi)

          // åˆ†å±‚åšåº¦
          const thickness = 4 * (1 - Math.abs(hy) / 20) // é¡¶éƒ¨å’Œåº•éƒ¨å˜è–„

          arr[i * 3] = hx * 0.8
          arr[i * 3 + 1] = hy * 0.8
          arr[i * 3 + 2] = (Math.random() - 0.5) * thickness * 2
        }
        return arr
      }

      // 3. åœŸæ˜Ÿ (çƒä½“ + ç¯)
      function getSaturnPoints(count) {
        const arr = new Float32Array(count * 3)
        const planetRatio = 0.4 // 40% ç²’å­åšæ˜Ÿçƒï¼Œ60% åšå…‰ç¯
        const planetCount = Math.floor(count * planetRatio)

        // æ˜Ÿçƒæœ¬ä½“
        for (let i = 0; i < planetCount; i++) {
          const p = randomPointInSphere(7)
          arr[i * 3] = p.x
          arr[i * 3 + 1] = p.y
          arr[i * 3 + 2] = p.z
        }

        // å…‰ç¯
        for (let i = planetCount; i < count; i++) {
          const angle = Math.random() * Math.PI * 2
          // å…‰ç¯åŠå¾„ 10 åˆ° 18
          const distance = 10 + Math.random() * 8
          arr[i * 3] = Math.cos(angle) * distance
          arr[i * 3 + 1] = (Math.random() - 0.5) * 0.5 // éå¸¸æ‰å¹³
          arr[i * 3 + 2] = Math.sin(angle) * distance

          // å€¾æ–œå…‰ç¯
          const x = arr[i * 3]
          const y = arr[i * 3 + 1]
          // ç»• Z è½´æ—‹è½¬ 30 åº¦
          const cosA = Math.cos(Math.PI / 6)
          const sinA = Math.sin(Math.PI / 6)
          arr[i * 3] = x * cosA - y * sinA
          arr[i * 3 + 1] = x * sinA + y * cosA
        }
        return arr
      }

      // 4. èŠ±æœµ (3D ç«ç‘°çº¿)
      function getFlowerPoints(count) {
        const arr = new Float32Array(count * 3)
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2
          const phi = Math.random() * Math.PI
          // ç«ç‘°çº¿æ–¹ç¨‹ r = cos(k * theta)
          const k = 3 // 3 petals
          const r = 10 * Math.sin(k * theta) * Math.sin(phi) + 2

          arr[i * 3] = r * Math.sin(phi) * Math.cos(theta)
          arr[i * 3 + 1] = r * Math.cos(phi)
          arr[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta)
        }
        return arr
      }

      // 5. ä½›åƒ (æ‹ŸäººåŒ–æ‰“åè½®å»“)
      function getBuddhaPoints(count) {
        const arr = new Float32Array(count * 3)

        // åˆ†é…ç²’å­ï¼šå¤´(15%)ï¼Œèº«èº¯(40%)ï¼Œè…¿/åº•åº§(45%)
        let idx = 0
        const headCount = Math.floor(count * 0.15)
        const bodyCount = Math.floor(count * 0.4)
        const legCount = count - headCount - bodyCount

        // å¤´éƒ¨ (çƒä½“)
        for (let i = 0; i < headCount; i++) {
          const p = randomPointInSphere(2.5)
          arr[idx++] = p.x
          arr[idx++] = p.y + 7 // æŠ¬é«˜
          arr[idx++] = p.z
        }

        // èº«ä½“ (æ¤­åœ†æŸ±/è›‹å½¢)
        for (let i = 0; i < bodyCount; i++) {
          const p = randomPointInSphere(4.5)
          arr[idx++] = p.x * 1.2 // å®½ä¸€ç‚¹
          arr[idx++] = p.y * 1.1 + 1
          arr[idx++] = p.z * 0.8
        }

        // ç›˜è…¿ (ä¸¤ä¸ªäº¤å‰çš„æ¤­çƒæˆ–æ‰å¹³çš„åœ†æŸ±)
        for (let i = 0; i < legCount; i++) {
          const angle = Math.random() * Math.PI // åŠåœ†
          const rad = 5 + Math.random() * 2
          // æ¨¡æ‹ŸåŒè…¿äº¤å‰çš„åŸºåº§
          const t = Math.random() * Math.PI * 2
          // ä¸€ä¸ªå®½æ‰çš„æ¤­åœ†åŸºåº§
          const x = (6 + Math.random() * 2) * Math.cos(t)
          const y = (2 + Math.random()) * Math.sin(t) - 4 // åº•éƒ¨
          const z = (5 + Math.random() * 2) * Math.sin(t)

          // ç¨å¾®éšæœºåŒ–å¡«å……å†…éƒ¨
          const r = Math.random()
          arr[idx++] = x * r
          arr[idx++] = -4 + Math.random() * 2
          arr[idx++] = z * r
        }

        return arr
      }

      // 6. çƒŸèŠ± (çˆ†ç‚¸æ€)
      function getFireworkPoints(count) {
        const arr = new Float32Array(count * 3)
        for (let i = 0; i < count; i++) {
          // ä»ä¸­å¿ƒå‘å¤–å‘å°„çš„å‘é‡ï¼Œå¤§éƒ¨åˆ†é›†ä¸­åœ¨å¤–éƒ¨
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(2 * Math.random() - 1)
          const r = 10 + Math.random() * 15 // è¾ƒå¤§èŒƒå›´

          arr[i * 3] = r * Math.sin(phi) * Math.cos(theta)
          arr[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta)
          arr[i * 3 + 2] = r * Math.cos(phi)
        }
        return arr
      }

      // åˆ‡æ¢æ¨¡å‹é€»è¾‘
      function setShape(shapeType) {
        currentShape = shapeType
        let newPoints

        switch (shapeType) {
          case 'heart':
            newPoints = getHeartPoints(CONFIG.particleCount)
            break
          case 'sphere':
            newPoints = getSpherePoints(CONFIG.particleCount, 12)
            break
          case 'saturn':
            newPoints = getSaturnPoints(CONFIG.particleCount)
            break
          case 'flower':
            newPoints = getFlowerPoints(CONFIG.particleCount)
            break
          case 'buddha':
            newPoints = getBuddhaPoints(CONFIG.particleCount)
            break
          case 'firework':
            newPoints = getFireworkPoints(CONFIG.particleCount)
            break
          default:
            newPoints = getSpherePoints(CONFIG.particleCount)
        }

        // æ›´æ–°ç›®æ ‡æ•°ç»„
        targetPositions = newPoints

        // æ›´æ–°æŒ‰é’® UI
        document.querySelectorAll('.shape-grid button').forEach(btn => btn.classList.remove('active'))
        event.target.classList.add('active')
      }

      // ================= 3. MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
      function initMediaPipe() {
        const hands = new Hands({
          locateFile: file => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          },
        })

        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        })

        hands.onResults(onHandsResults)

        const cameraUtils = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement })
          },
          width: 640,
          height: 480,
        })
        cameraUtils
          .start()
          .then(() => {
            document.getElementById('loader').style.opacity = '0'
            setTimeout(() => (document.getElementById('loader').style.display = 'none'), 500)
          })
          .catch(err => {
            console.error('Camera error:', err)
            document.getElementById('loader-text').innerHTML = 'æ— æ³•è®¿é—®æ‘„åƒå¤´<br>è¯·æ£€æŸ¥æƒé™æˆ–åˆ·æ–°é¡µé¢'
          })
      }

      function onHandsResults(results) {
        // ç»˜åˆ¶é¢„è§ˆå°çª—
        previewCtx.save()
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height)
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height)
        if (results.multiHandLandmarks) {
          for (const landmarks of results.multiHandLandmarks) {
            drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 })
          }
        }
        previewCtx.restore()

        // é€»è¾‘å¤„ç†
        const handDot = document.getElementById('hand-dot')
        const statusText = document.getElementById('status-text')

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          isHandDetected = true
          handDot.classList.add('active')

          let dist = 0

          // æ¨¡å¼ 1ï¼šæ£€æµ‹åˆ°ä¸¤åªæ‰‹ -> è®¡ç®—åŒæ‰‹è·ç¦»
          if (results.multiHandLandmarks.length === 2) {
            statusText.innerText = 'åŒæ‰‹æ¨¡å¼ï¼šæ§åˆ¶æ‰©æ•£'
            const hand1 = results.multiHandLandmarks[0][9] // ä¸­æŒ‡æ ¹éƒ¨
            const hand2 = results.multiHandLandmarks[1][9]

            // è®¡ç®—å½’ä¸€åŒ–è·ç¦»
            const dx = hand1.x - hand2.x
            const dy = hand1.y - hand2.y
            const rawDist = Math.sqrt(dx * dx + dy * dy)

            // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾æ¯”ä¾‹ (ä¸€èˆ¬åŒæ‰‹è·ç¦»åœ¨ 0.1 åˆ° 0.8 ä¹‹é—´)
            // ç›®æ ‡ scale: 0.5 (åˆæ‹¢) åˆ° 3.0 (å¼ å¼€)
            dist = mapRange(rawDist, 0.1, 0.7, 0.5, 3.5)
          }
          // æ¨¡å¼ 2ï¼šæ£€æµ‹åˆ°ä¸€åªæ‰‹ -> è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦» (æåˆ)
          else {
            statusText.innerText = 'å•æ‰‹æ¨¡å¼ï¼šæåˆç¼©æ”¾'
            const lm = results.multiHandLandmarks[0]
            const thumb = lm[4]
            const index = lm[8]

            const rawDist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2))
            // å•æ‰‹æåˆè·ç¦»ä¸€èˆ¬ 0.02 åˆ° 0.25
            dist = mapRange(rawDist, 0.05, 0.25, 0.5, 2.5)
          }

          targetScale = Math.max(0.2, Math.min(dist, 5.0)) // é™åˆ¶èŒƒå›´
        } else {
          isHandDetected = false
          handDot.classList.remove('active')
          statusText.innerText = 'ç­‰å¾…æ‰‹åŠ¿...'
          // æ— æ‰‹åŠ¿æ—¶ï¼Œç¼“ç¼“å‘¼å¸æ•ˆæœ
          const time = Date.now() * 0.001
          targetScale = 1.0 + Math.sin(time) * 0.1
        }
      }

      // å·¥å…·ï¼šæ•°å€¼æ˜ å°„
      function mapRange(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin
      }

      // ================= 4. åŠ¨ç”»å¾ªç¯ =================
      function animate() {
        requestAnimationFrame(animate)

        if (!particles) return

        // 1. ç²’å­å½¢æ€æ’å€¼ (Lerp)
        const positions = particles.geometry.attributes.position.array

        // å¹³æ»‘è¿‡æ¸¡ Scale
        handScale += (targetScale - handScale) * 0.1

        for (let i = 0; i < CONFIG.particleCount; i++) {
          const ix = i * 3
          const iy = i * 3 + 1
          const iz = i * 3 + 2

          // è·å–ç›®æ ‡ç‚¹
          const tx = targetPositions[ix]
          const ty = targetPositions[iy]
          const tz = targetPositions[iz]

          // è·å–å½“å‰ç‚¹
          let cx = currentPositions[ix]
          let cy = currentPositions[iy]
          let cz = currentPositions[iz]

          // å‘ç›®æ ‡ç§»åŠ¨
          cx += (tx - cx) * CONFIG.transitionSpeed
          cy += (ty - cy) * CONFIG.transitionSpeed
          cz += (tz - cz) * CONFIG.transitionSpeed

          // æ›´æ–°ç¼“å­˜çš„å½“å‰ä½ç½® (æœªç¼©æ”¾)
          currentPositions[ix] = cx
          currentPositions[iy] = cy
          currentPositions[iz] = cz

          // åº”ç”¨æ‰‹åŠ¿ç¼©æ”¾å¹¶èµ‹å€¼ç»™ geometry
          // å¢åŠ ä¸€ç‚¹å™ªç‚¹æŠ–åŠ¨ï¼Œè®©ç²’å­çœ‹èµ·æ¥æ˜¯æ´»çš„
          const noise = 0.02
          positions[ix] = cx * handScale + (Math.random() - 0.5) * noise
          positions[iy] = cy * handScale + (Math.random() - 0.5) * noise
          positions[iz] = cz * handScale + (Math.random() - 0.5) * noise
        }

        particles.geometry.attributes.position.needsUpdate = true

        // 2. æ•´ä½“æ—‹è½¬
        particles.rotation.y += 0.002
        // æ ¹æ®æ‰‹åŠ¿ç¨å¾®å€¾æ–œ
        if (isHandDetected) {
          particles.rotation.z = (handScale - 1) * 0.2
        }

        renderer.render(scene, camera)
      }

      // ================= 5. å·¥å…·å‡½æ•° =================
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function toggleFullScreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen()
          document.getElementById('fullscreen-btn').innerText = 'âŒ é€€å‡ºå…¨å±'
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen()
            document.getElementById('fullscreen-btn').innerText = 'â›¶ å…¨å±æ¨¡å¼'
          }
        }
      }

      // ================= å¯åŠ¨ =================
      window.onload = function () {
        // è®¾ç½®é¢„è§ˆç”»å¸ƒå¤§å°
        previewCanvas.width = 160
        previewCanvas.height = 120

        initThree()
        initMediaPipe()
        animate()
      }
    </script>
  </body>
</html>
